
#!/usr/bin/env bash
# scaffold-hooks.sh - Creates the complete Claude Code hooks directory structure
# Usage: scaffold-hooks.sh [target_dir]
# If target_dir is not provided, uses $CLAUDE_PROJECT_DIR or current directory

set -euo pipefail

# ─── CONFIG ─────────────────────────────────────────────────────────────────
TARGET_DIR="${1:-${CLAUDE_PROJECT_DIR:-$(pwd)}}"
HOOKS_DIR="$TARGET_DIR/.claude/hooks"
VERBOSE="${VERBOSE:-false}"

# ─── HELPERS ────────────────────────────────────────────────────────────────
log() { echo "[scaffold] $*"; }
debug() { [[ "$VERBOSE" == "true" ]] && echo "[debug] $*" || true; }

create_dir() {
    if [[ ! -d "$1" ]]; then
        mkdir -p "$1"
        log "Created: $1"
    else
        debug "Exists: $1"
    fi
}

create_file() {
    local path="$1"
    local content="$2"
    if [[ ! -f "$path" ]]; then
        echo "$content" > "$path"
        log "Created: $path"
    else
        debug "Exists: $path"
    fi
}

# ─── MAIN ───────────────────────────────────────────────────────────────────
log "Scaffolding hooks structure in: $HOOKS_DIR"

# Create main directories
create_dir "$HOOKS_DIR"
create_dir "$HOOKS_DIR/utils"
create_dir "$HOOKS_DIR/scripts"
create_dir "$HOOKS_DIR/scripts/logs"
create_dir "$HOOKS_DIR/scripts/reports"
create_dir "$HOOKS_DIR/logs"
create_dir "$HOOKS_DIR/tests"
create_dir "$HOOKS_DIR/hooks-templates"
create_dir "$HOOKS_DIR/hooks-language-guide"
create_dir "$HOOKS_DIR/hooks-user-output-templates"

# Create utils subdirectories for each event type
EVENTS=("preToolUse" "postToolUse" "sessionStart" "sessionEnd" "stop" "subagentStart" "subagentStop" "userPromptSubmit")
for event in "${EVENTS[@]}"; do
    create_dir "$HOOKS_DIR/utils/$event"
done

# Create hooks-config.json
create_file "$HOOKS_DIR/hooks-config.json" '{
  "$schema": "https://json-schema.org/draft-07/schema#",
  "version": "1.0.0",
  "description": "Claude Code hooks configuration and documentation",
  "hooks": {
    "PreToolUse": [],
    "PostToolUse": [],
    "SessionStart": [],
    "SessionEnd": [],
    "Stop": [],
    "SubagentStart": [],
    "SubagentStop": [],
    "UserPromptSubmit": [],
    "PreCompact": [],
    "Notification": []
  },
  "metadata": {
    "totalHooks": 0,
    "lastUpdated": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"
  },
  "notes": [
    "Add hook configurations to the appropriate event array",
    "Each hook should have: name, script, matcher (if applicable), timeout, description",
    "Timeout is in milliseconds in this file, but seconds in settings.json"
  ]
}'

# Create CHANGELOG.md
create_file "$HOOKS_DIR/CHANGELOG.md" '# Hooks Changelog

All notable changes to hooks are documented here.

## [Unreleased]

### Added
- Initial hooks structure scaffolded

---

## Format

```markdown
## [YYYY-MM-DD] - hook-name

### Added/Changed/Removed
- Description of change
```
'

# Create CLAUDE.md for hooks context
create_file "$HOOKS_DIR/CLAUDE.md" '<claude-mem-context>
# Recent Activity

<!-- This section is auto-generated by claude-mem. Edit content outside the tags. -->

*No recent activity*
</claude-mem-context>
'

# Create hooks-language-guide/README.md
create_file "$HOOKS_DIR/hooks-language-guide/README.md" '# Hook Language Selection Guide

## Quick Decision Tree

| Complexity | Language | Use When |
|------------|----------|----------|
| Simple gating | **Bash** | Fast checks, allowlist/denylist, PreToolUse default |
| Complex logic | **Python** | Multi-stage transforms, structured data, scoring |
| Async I/O | **Node.js** | HTTP calls, parallel reads, JS/TS ecosystem |

## Performance Budgets

- `PreToolUse`: < 100ms (blocks user action)
- `PostToolUse`: < 500ms (tracking/logging)
- `Stop`: < 30s (auto-fixing)

## Files

- `bash.md` - Bash patterns and examples
- `python.md` - Python patterns and examples
- `node.md` - Node.js patterns and examples
'

# Create bash.md template
create_file "$HOOKS_DIR/hooks-language-guide/bash.md" '# Bash Hook Patterns

## Template

```bash
#!/usr/bin/env bash
set -euo pipefail

# Read stdin ONCE
payload="$(cat)"

# Parse with jq
tool_name=$(echo "$payload" | jq -r ".tool_name // empty")
hook_event=$(echo "$payload" | jq -r ".hook_event_name // empty")

# Fast-path exit for non-matching
[[ "$tool_name" == "ExpectedTool" ]] || exit 0

# Your logic here

# Output JSON
jq -n --arg event "$hook_event" '"'"'{
  hookSpecificOutput: {
    hookEventName: $event,
    permissionDecision: "allow"
  }
}'"'"'
exit 0
```

## Exit Codes

| Exit | PreToolUse | PostToolUse | Stop |
|------|------------|-------------|------|
| 0 | Allow | Success | Allow stop |
| 1 | Error (pass) | Error (ignore) | Error |
| 2 | Block | N/A | Force continue |
'

# Create python.md template
create_file "$HOOKS_DIR/hooks-language-guide/python.md" '# Python Hook Patterns

## Template

```python
#!/usr/bin/env python3
import sys
import json

def main():
    payload = json.load(sys.stdin)
    tool_name = payload.get("tool_name", "")
    hook_event = payload.get("hook_event_name", "")

    # Fast-path exit
    if tool_name != "ExpectedTool":
        sys.exit(0)

    # Your logic here

    # Output JSON
    result = {
        "hookSpecificOutput": {
            "hookEventName": hook_event,
            "permissionDecision": "allow"
        }
    }
    print(json.dumps(result))
    sys.exit(0)

if __name__ == "__main__":
    main()
```
'

# Create node.md template
create_file "$HOOKS_DIR/hooks-language-guide/node.md" '# Node.js Hook Patterns

## Template

```javascript
#!/usr/bin/env node
const fs = require("fs");

async function main() {
  const payload = JSON.parse(fs.readFileSync(0, "utf-8"));
  const toolName = payload.tool_name || "";
  const hookEvent = payload.hook_event_name || "";

  // Fast-path exit
  if (toolName !== "ExpectedTool") {
    process.exit(0);
  }

  // Your logic here

  // Output JSON
  const result = {
    hookSpecificOutput: {
      hookEventName: hookEvent,
      permissionDecision: "allow"
    }
  };
  console.log(JSON.stringify(result));
  process.exit(0);
}

main().catch(err => {
  console.error(err.message);
  process.exit(1);
});
```
'

# Create hook event templates
TEMPLATE_EVENTS=("preToolUse" "postToolUse" "sessionStart" "sessionEnd" "stop" "subagentStart" "subagentStop" "userPromptSubmit" "preCompact" "notification")

for event in "${TEMPLATE_EVENTS[@]}"; do
    # Convert to PascalCase for display
    pascal_event=$(echo "$event" | sed -r 's/(^|_)([a-z])/\U\2/g')

    create_file "$HOOKS_DIR/hooks-templates/$event.sh" '#!/usr/bin/env bash
# Template for '"$pascal_event"' hooks
set -euo pipefail

payload="$(cat)"
hook_event=$(echo "$payload" | jq -r ".hook_event_name // empty")

# === AVAILABLE FIELDS ===
# tool_name, tool_input (PreToolUse, PostToolUse)
# tool_response (PostToolUse only)
# session_id, prompt (UserPromptSubmit)
# source (SessionStart: startup|resume|clear|compact)
# agent_id, agent_type (SubagentStart, SubagentStop)
# stop_hook_active (SubagentStop)

# === YOUR LOGIC HERE ===


# === OUTPUT ===
# Exit 0 = success (JSON parsed)
# Exit 2 = block (stderr shown to Claude, PreToolUse/Stop/SubagentStop only)

jq -n --arg event "$hook_event" '"'"'{
  hookSpecificOutput: {
    hookEventName: $event
  }
}'"'"'
exit 0
'
    chmod +x "$HOOKS_DIR/hooks-templates/$event.sh" 2>/dev/null || true
done

# Create hooks-user-output-templates/README.md
create_file "$HOOKS_DIR/hooks-user-output-templates/README.md" '# Hook User Output Templates

Templates for user-visible feedback patterns.

## Output Types

| Field | Visibility | Token Cost |
|-------|------------|------------|
| `systemMessage` | User only | 0 tokens |
| `additionalContext` | Claude only | Costs tokens |
| `suppressOutput` | Hide from transcript | - |

## Files

- `bash.md` - Bash output patterns
- `python.md` - Python output patterns
- `node.md` - Node.js output patterns
'

# Create test files
create_file "$HOOKS_DIR/tests/TESTING.md" '# Hook Testing Guide

## Quick Test Commands

```bash
# Syntax check
bash -n .claude/hooks/utils/preToolUse/my-hook.sh

# Unit test with sample payload
echo '"'"'{"tool_name": "Write", "hook_event_name": "PreToolUse"}'"'"' | bash .claude/hooks/utils/preToolUse/my-hook.sh

# Run all tests
bash .claude/hooks/tests/run-all-tests.sh
```

## Test File Convention

For each hook `my-hook.sh`, create `my-hook.test.sh` in the same directory.
'

create_file "$HOOKS_DIR/tests/run-all-tests.sh" '#!/usr/bin/env bash
# Run all hook tests
set -euo pipefail

HOOKS_DIR="${CLAUDE_PROJECT_DIR:-.}/.claude/hooks"
FAILED=0

echo "=== Running Hook Tests ==="

for test_file in $(find "$HOOKS_DIR/utils" -name "*.test.sh" 2>/dev/null); do
    echo "Running: $test_file"
    if bash "$test_file"; then
        echo "  ✓ PASS"
    else
        echo "  ✗ FAIL"
        FAILED=$((FAILED + 1))
    fi
done

echo ""
if [ $FAILED -eq 0 ]; then
    echo "All tests passed!"
    exit 0
else
    echo "$FAILED test(s) failed"
    exit 1
fi
'
chmod +x "$HOOKS_DIR/tests/run-all-tests.sh" 2>/dev/null || true

create_file "$HOOKS_DIR/tests/test-helper.sh" '#!/usr/bin/env bash
# Test helper functions

# Assert exit code
assert_exit() {
    local expected=$1
    local actual=$2
    if [ "$expected" != "$actual" ]; then
        echo "FAIL: Expected exit $expected, got $actual"
        return 1
    fi
}

# Assert JSON field exists
assert_json_field() {
    local json="$1"
    local field="$2"
    if ! echo "$json" | jq -e "$field" > /dev/null 2>&1; then
        echo "FAIL: Missing field $field"
        return 1
    fi
}
'

# Summary
echo ""
log "=== Scaffolding Complete ==="
log "Structure created at: $HOOKS_DIR"
log ""
log "Next steps:"
log "  1. Add hooks to .claude/settings.json"
log "  2. Create hook scripts in utils/{eventType}/"
log "  3. Document in hooks-config.json"
log "  4. Update CHANGELOG.md"
